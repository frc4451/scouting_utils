import pandas as pd
import numpy as np
import argparse
import os
import fpdf


def create_assigned_groups_from_df(student_df: pd.DataFrame, batch_keys=["A", "B", "C", "D"], shuffle=True) -> pd.DataFrame:
    """ 
    Accepts a DataFrame containing the "student_name" and "student_team" 
    keys and assigns a group from `batch_keys` to each student.

    This function assumes we want to randomize the dataset.
    """
    # Shuffle the names
    if shuffle:
        student_df = student_df.sample(frac=1).reset_index(drop=True)

    # Assign batches row-wise to the new DataFrame
    assigned_groups = pd.DataFrame(
        columns=["student_name", "student_team", "assigned_group"])
    for index, row in student_df.iterrows():
        batch_name = batch_keys[index % len(batch_keys)]
        assigned_groups = pd.concat([assigned_groups, pd.DataFrame({
            "student_name": [row["student_name"]],
            "student_team": [row["student_team"]],
            "assigned_group": [batch_name]
        })], ignore_index=True)

    # We want to sort the dataframe by assigned_group for clarity
    assigned_groups = assigned_groups.sort_values("assigned_group")

    # Use a temporary group_indicator to help us group each index of
    # the group and append a numerical value we plan to use as the lookup
    # key in the match scouting schedule.
    assigned_groups['group_indicator'] = 1 + (
        assigned_groups.index // len(batch_keys)
    )
    assigned_groups['match_key'] = assigned_groups['assigned_group'] + \
        assigned_groups['group_indicator'].astype(str)
    assigned_groups = assigned_groups.drop(columns=['group_indicator'])

    assigned_groups = assigned_groups.sort_values(by=['match_key'], ascending=True)

    return assigned_groups


def generate_match_schedule(assignments: pd.DataFrame, num_matches=50, shift_length=6) -> pd.DataFrame:
    """
    Given a DataFrame that was generated by `create_assigned_groups_from_df`,
    we can create a match schedule off of `num_matches` and the `shift_length`
    we want for scouters. This also includes shuffling scouters around so that
    everyone has a chance to not be a backseat.
    """
    # Assume that matches are the primary index we use to display.
    # We can build the rest of the columns from this.
    matches = pd.DataFrame(np.arange(1, num_matches+1),
                           columns=['match_number'])

    # Calculate the floor and assign that to our shift for groupby
    matches['shift'] = (matches.index // shift_length) + 1

    # This is going to be overwritten later, we just want to define it
    # for formatting on the end.
    matches['matches'] = None

    # Group matches by "shifts" and assigned groups by their assignments
    grouped_by_shift = matches.groupby('shift')

    # Filter out groups ahead of time
    group_a = assignments[assignments['assigned_group'] == 'A']
    group_b = assignments[assignments['assigned_group'] == 'B']
    group_c = assignments[assignments['assigned_group'] == 'C']
    group_d = assignments[assignments['assigned_group'] == 'D']

    # We use this to help with code generation when looking up our
    # scouter identifiers
    red_lookup = {
        'R1': 0,
        'R2': 1,
        'R3': 2,
        'RB': 3,
    }
    blue_lookup = {
        'B1': 0,
        'B2': 1,
        'B3': 2,
        'BB': 3,
    }

    # Iterate groups of shifts and assign scouters to a specific team position.
    # We re-sample the groups every shift so we can try to give every scouter
    # a chance at scouting and not being stuck on the backup.
    shift_assignments = []
    for _, shift_df in grouped_by_shift:
        group_a = group_a.sample(frac=1).reset_index(drop=True)
        group_b = group_b.sample(frac=1).reset_index(drop=True)
        group_c = group_c.sample(frac=1).reset_index(drop=True)
        group_d = group_d.sample(frac=1).reset_index(drop=True)

        for key, value in red_lookup.items():
            shift_df[key] = np.where(
                shift_df['shift'] % 2 == 0,
                group_a.iloc[value]['match_key'],
                group_c.iloc[value]['match_key'],
            )
        for key, value in blue_lookup.items():
            shift_df[key] = np.where(
                shift_df['shift'] % 2 == 0,
                group_b.iloc[value]['match_key'],
                group_d.iloc[value]['match_key'],
            )

        # We'll drop match_number and just show the range of matches
        shift_df['matches'] = f"{shift_df['match_number'].min()} - {shift_df['match_number'].max()}"

        shift_assignments.append(shift_df)

    # Our resulting shift dataframes can be merged with concat
    ungrouped_df = pd.concat(shift_assignments)

    # temp cleanup
    ungrouped_df = ungrouped_df.drop(columns=['match_number'])
    ungrouped_df = ungrouped_df.drop_duplicates()

    return ungrouped_df


def write_df_to_pdf(scouter_df: pd.DataFrame, matches_df: pd.DataFrame, file_name: str, event: str):
    """
    Takes a Pandas DataFrame and writes the contents of the dataframe
    to a PDF with the specified `file_name`.

    This script also provides auto-formatting so our column width is the
    exact amount needed to fit all columns on the page equally.
    """
    pdf = fpdf.FPDF()
    pdf.add_page()

    pdf.set_font("Arial", size=12)
    
    # Help build lookups so we can use the name of the student in the actual schedule
    match_lookup = {}
    for _, row in scouter_df.iterrows():
        match_lookup[row['match_key']] = row['student_name']

    scouter_df = scouter_df.drop(columns=['match_key'])
    
    # Calculates available column width on PDF
    available_width = pdf.w - (pdf.l_margin + pdf.r_margin)
    column_width = available_width / len(scouter_df.columns)

    # Generate column headers
    for col in scouter_df.columns:
        pdf.cell(column_width, 10, col, border=1)
    pdf.ln()

    # Generate subsequent rows from the columns in the dataframe
    for _, row in scouter_df.iterrows():
        for col in scouter_df.columns:
            pdf.cell(column_width, 10, str(row[col]), border=1)
        pdf.ln()

    # Calculates available column width on PDF
    available_width = pdf.w - (pdf.l_margin + pdf.r_margin)
    column_width = available_width / len(matches_df.columns)


    # pdf.add_page()
    # pdf.set_font("Arial", size=12)

    # # Generate column headers
    # for col in matches_df.columns:
    #     pdf.cell(column_width, 10, col, border=1)
    # pdf.ln()

    # # Generate subsequent rows from the columns in the dataframe
    # for _, row in matches_df.iterrows():
    #     for col in matches_df.columns:
    #         pdf.cell(column_width, 10, str(row[col]), border=1)
    #     pdf.ln()


    pdf.add_page()
    pdf.set_font("Arial", size=12)

    pdf.cell(available_width, 10, f"Schedule for {event}", border=1, align="C")
    pdf.ln()
    pdf.ln()

    # Actually build the schedule for students
    third_width = available_width / 3
    fifth_width = available_width / 5
    for _, row, in matches_df.iterrows():
        # if int(row['shift']) % 6 == 0:
        #     pdf.add_page()
        #     pdf.set_font("Arial", size=12)

        pdf.cell(third_width, 10, f"Shift #{str(row['shift'])}", border=1, align="C")
        pdf.cell(third_width * 2, 10, f"Matches: {str(row['matches'])}", border=1, align="C")
        pdf.ln()
        pdf.cell(fifth_width, 10, "", border=1, align="C")
        pdf.cell(fifth_width, 10, "1", border=1, align="C")
        pdf.cell(fifth_width, 10, "2", border=1, align="C")
        pdf.cell(fifth_width, 10, "3", border=1, align="C")
        pdf.cell(fifth_width, 10, "Backup", border=1, align="C")
        pdf.ln()
        pdf.cell(fifth_width, 10, "R", border=1, align="C")
        pdf.cell(fifth_width, 10, match_lookup[str(row['R1'])], border=1, align="C")
        pdf.cell(fifth_width, 10, match_lookup[str(row['R2'])], border=1, align="C")
        pdf.cell(fifth_width, 10, match_lookup[str(row['R3'])], border=1, align="C")
        pdf.cell(fifth_width, 10, match_lookup[str(row['RB'])], border=1, align="C")
        pdf.ln()
        pdf.cell(fifth_width, 10, "B", border=1, align="C")
        pdf.cell(fifth_width, 10, match_lookup[str(row['B1'])], border=1, align="C")
        pdf.cell(fifth_width, 10, match_lookup[str(row['B2'])], border=1, align="C")
        pdf.cell(fifth_width, 10, match_lookup[str(row['B3'])], border=1, align="C")
        pdf.cell(fifth_width, 10, match_lookup[str(row['BB'])], border=1, align="C")
        pdf.ln()
        pdf.ln()


    # Write file
    pdf.output(file_name)

def create_default_output_directory() -> str:
    """
    Handles default output directory creation if the default output directory
    does not exist.
    """
    default_write_directory: str = os.path.join(os.getcwd(), 'output_data', 'schedules')

    # os.mkdir(default_write_directory)
    if not os.path.exists(default_write_directory):
        os.makedirs(default_write_directory)

    return default_write_directory


if __name__ == "__main__":
    # Handles CLI arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('--input', type=str,
                        help='Input file path. Expects CSV input.', required=True)
    parser.add_argument('--event', type=str,
                        help='Evnet for labelling the schedule', required=True)
    parser.add_argument('--out_path', type=str,
                        help='Output directory.', default=create_default_output_directory())
                        # help='Output directory.', default=os.path.join(os.getcwd(), 'output_data'))
    parser.add_argument('--num_matches', type=int,
                        help='Number of matches in the competition at the event.', default=50)
    args = parser.parse_args()
    input_file = args.input
    num_matches_input = args.num_matches
    output_path = args.out_path
    event = args.event

    df = pd.read_csv(input_file)

    assigned_group = create_assigned_groups_from_df(student_df=df)

    match_schedule = generate_match_schedule(
        assignments=assigned_group, num_matches=num_matches_input)

    # Save the assigned groups to a new CSV file
    write_df_to_pdf(scouter_df=assigned_group,
                    matches_df=match_schedule,
                    event=event,
                    file_name=os.path.join(output_path, "assigned_groups.pdf"))
